#!/usr/bin/env python3
"""
PenTest Command & Control Dashboard
Advanced penetration testing server management interface
"""

import os
import sys
import json
import threading
import subprocess
import signal
import hashlib
from datetime import datetime, timedelta
from flask import Flask, render_template, request, jsonify, send_from_directory, session, redirect, url_for
from flask_socketio import SocketIO, emit
import psutil
from functools import wraps

app = Flask(__name__)
app.config['SECRET_KEY'] = os.urandom(24)
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=24)
socketio = SocketIO(app, cors_allowed_origins="*")

# Security Configuration
MASTER_PASSWORD = "hamza_sku_2026"
PASSWORD_HASH = hashlib.sha256(MASTER_PASSWORD.encode()).hexdigest()

def login_required(f):
    """Decorator to protect routes"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get('authenticated'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

# Global state
class ServerState:
    def __init__(self):
        self.is_running = False
        self.listener_process = None
        self.listener_port = 4444
        self.commands_history = []
        self.sessions = []
        self.logs = []
        self.start_time = None
        self.stats = {
            'commands_executed': 0,
            'sessions_established': 0,
            'data_transferred': 0
        }
    
    def add_log(self, level, message):
        log_entry = {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'level': level,
            'message': message
        }
        self.logs.append(log_entry)
        if len(self.logs) > 1000:
            self.logs = self.logs[-1000:]
        socketio.emit('new_log', log_entry)
        return log_entry

state = ServerState()

@app.route('/')
@login_required
def index():
    return render_template('dashboard.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        data = request.json
        password = data.get('password', '')
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        
        if password_hash == PASSWORD_HASH:
            session['authenticated'] = True
            session.permanent = True
            state.add_log('success', f'Login successful from {request.remote_addr}')
            return jsonify({'success': True, 'message': 'Login successful'})
        else:
            state.add_log('warning', f'Failed login attempt from {request.remote_addr}')
            return jsonify({'success': False, 'message': 'Invalid password'})
    
    if session.get('authenticated'):
        return redirect(url_for('index'))
    
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.clear()
    state.add_log('info', 'User logged out')
    return redirect(url_for('login'))

@app.route('/api/status')
@login_required
def get_status():
    """Get current server status"""
    cpu_percent = psutil.cpu_percent(interval=0.1)
    memory = psutil.virtual_memory()
    
    uptime = None
    if state.start_time:
        uptime = (datetime.now() - state.start_time).total_seconds()
    
    return jsonify({
        'is_running': state.is_running,
        'port': state.listener_port,
        'stats': state.stats,
        'uptime': uptime,
        'system': {
            'cpu': cpu_percent,
            'memory': memory.percent,
            'connections': len(state.sessions)
        }
    })

@app.route('/api/start', methods=['POST'])
@login_required
def start_server():
    """Start the listener server"""
    if state.is_running:
        return jsonify({'success': False, 'message': 'Server already running'})
    
    try:
        data = request.json
        state.listener_port = data.get('port', 4444)
        
        # Create a simple netcat listener (for demonstration)
        # In production, replace with actual penetration testing framework
        cmd = f"nc -lvnp {state.listener_port}"
        
        state.listener_process = subprocess.Popen(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE
        )
        
        state.is_running = True
        state.start_time = datetime.now()
        state.add_log('success', f'Listener started on port {state.listener_port}')
        
        # Start monitoring thread
        threading.Thread(target=monitor_listener, daemon=True).start()
        
        return jsonify({'success': True, 'message': f'Listener started on port {state.listener_port}'})
    
    except Exception as e:
        state.add_log('error', f'Failed to start listener: {str(e)}')
        return jsonify({'success': False, 'message': str(e)})

@app.route('/api/stop', methods=['POST'])
@login_required
def stop_server():
    """Stop the listener server"""
    if not state.is_running:
        return jsonify({'success': False, 'message': 'Server not running'})
    
    try:
        if state.listener_process:
            state.listener_process.terminate()
            state.listener_process.wait(timeout=5)
        
        state.is_running = False
        state.start_time = None
        state.add_log('warning', 'Listener stopped')
        
        return jsonify({'success': True, 'message': 'Listener stopped'})
    
    except Exception as e:
        state.add_log('error', f'Failed to stop listener: {str(e)}')
        return jsonify({'success': False, 'message': str(e)})

@app.route('/api/command', methods=['POST'])
@login_required
def execute_command():
    """Execute a command"""
    data = request.json
    command = data.get('command', '').strip()
    
    if not command:
        return jsonify({'success': False, 'message': 'Empty command'})
    
    state.commands_history.append({
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'command': command
    })
    
    try:
        # Execute command in listener context
        if state.listener_process and state.is_running:
            state.listener_process.stdin.write(f"{command}\n".encode())
            state.listener_process.stdin.flush()
            
            state.stats['commands_executed'] += 1
            state.add_log('info', f'Command executed: {command}')
            
            return jsonify({'success': True, 'message': 'Command sent'})
        else:
            return jsonify({'success': False, 'message': 'Listener not running'})
    
    except Exception as e:
        state.add_log('error', f'Command execution failed: {str(e)}')
        return jsonify({'success': False, 'message': str(e)})

@app.route('/api/logs')
@login_required
def get_logs():
    """Get recent logs"""
    return jsonify({'logs': state.logs[-100:]})

@app.route('/api/history')
@login_required
def get_history():
    """Get command history"""
    return jsonify({'history': state.commands_history[-50:]})

def monitor_listener():
    """Monitor listener process output"""
    while state.is_running and state.listener_process:
        try:
            line = state.listener_process.stdout.readline()
            if line:
                output = line.decode('utf-8', errors='ignore').strip()
                if output:
                    socketio.emit('listener_output', {'output': output})
                    state.add_log('info', f'Output: {output}')
        except Exception as e:
            break

@socketio.on('connect')
def handle_connect():
    state.add_log('info', 'Client connected to dashboard')
    emit('connection_response', {'status': 'connected'})

@socketio.on('disconnect')
def handle_disconnect():
    state.add_log('info', 'Client disconnected from dashboard')

def signal_handler(sig, frame):
    """Handle shutdown gracefully"""
    print("\n[!] Shutting down...")
    if state.is_running:
        stop_server()
    sys.exit(0)

if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal_handler)
    
    # Create templates directory
    os.makedirs('templates', exist_ok=True)
    
    print("""
    ╔═══════════════════════════════════════════════════════════╗
    ║   PenTest Command & Control Dashboard                    ║
    ║   Advanced Penetration Testing Server Management         ║
    ╚═══════════════════════════════════════════════════════════╝
    
    [+] Dashboard starting...
    [+] Access at: http://localhost:5000
    [!] Press Ctrl+C to stop
    """)
    
    state.add_log('success', 'Dashboard initialized')
    socketio.run(app, host='0.0.0.0', port=5000, debug=False, allow_unsafe_werkzeug=True)
