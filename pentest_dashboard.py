#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PenTest C2 Dashboard - Real Version
Ø­Ù‚ÙŠÙ‚ÙŠ 100% - Ù„Ø§ ØªÙˆØ¬Ø¯ targets ÙˆÙ‡Ù…ÙŠØ©
"""

from flask import Flask, render_template, jsonify, request, session, redirect, url_for
from flask_socketio import SocketIO, emit
import subprocess
import psutil
import threading
import time
import hashlib
import json
import os
from datetime import datetime, timedelta
import socket
import re

app = Flask(__name__)
app.config['SECRET_KEY'] = 'hamza_sku_secret_2026_real'
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=12)
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading')

# ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ù…Ø´ÙØ±Ø© Ø¨Ù€ SHA-256
# Password: hamza_sku_2026
ADMIN_PASSWORD_HASH = "8f3e8c8f7c5c4e5f9e6a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e"

class SystemState:
    def __init__(self):
        self.is_running = False
        self.listener_process = None
        self.listener_port = None
        self.listener_host = None
        self.targets = {}  # {ip: {device, os, last_seen, status}}
        self.commands_executed = 0
        self.start_time = None
        self.logs = []
        self.connection_monitor_thread = None
        self.stop_monitor = False
        
    def add_log(self, level, message):
        """Ø¥Ø¶Ø§ÙØ© Ø³Ø¬Ù„ Ø¬Ø¯ÙŠØ¯"""
        log_entry = {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'level': level,
            'message': message
        }
        self.logs.append(log_entry)
        # Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø¢Ø®Ø± 100 Ø³Ø¬Ù„ ÙÙ‚Ø·
        if len(self.logs) > 100:
            self.logs = self.logs[-100:]
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø³Ø¬Ù„ Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© ÙÙˆØ±Ø§Ù‹
        try:
            socketio.emit('new_log', log_entry)
        except:
            pass
    
    def add_target(self, ip, device_info=None):
        """Ø¥Ø¶Ø§ÙØ© target Ø­Ù‚ÙŠÙ‚ÙŠ"""
        if ip not in self.targets:
            target_data = {
                'ip': ip,
                'device': device_info or 'Unknown Device',
                'os': self.detect_os(ip),
                'last_seen': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'status': 'online'
            }
            self.targets[ip] = target_data
            self.add_log('SUCCESS', f'ğŸ¯ New target detected: {ip}')
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„ÙˆØ§Ø¬Ù‡Ø©
            try:
                socketio.emit('new_target', target_data)
            except:
                pass
            
            return True
        else:
            # ØªØ­Ø¯ÙŠØ« Ø¢Ø®Ø± Ù…Ø±Ø© Ø´ÙˆÙ‡Ø¯ ÙÙŠÙ‡Ø§
            self.targets[ip]['last_seen'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            self.targets[ip]['status'] = 'online'
            return False
    
    def detect_os(self, ip):
        """Ù…Ø­Ø§ÙˆÙ„Ø© ÙƒØ´Ù Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„"""
        try:
            # TTL-based OS detection (ØªÙ‚Ø±ÙŠØ¨ÙŠ)
            result = subprocess.run(['ping', '-c', '1', '-W', '1', ip], 
                                  capture_output=True, text=True, timeout=2)
            if result.returncode == 0:
                if 'ttl=64' in result.stdout.lower():
                    return 'Linux/Android'
                elif 'ttl=128' in result.stdout.lower():
                    return 'Windows'
                elif 'ttl=255' in result.stdout.lower() or 'ttl=64' in result.stdout.lower():
                    return 'iOS/MacOS'
        except:
            pass
        return 'Unknown'
    
    def get_stats(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©"""
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        
        uptime = "00:00:00"
        if self.start_time:
            elapsed = datetime.now() - self.start_time
            hours, remainder = divmod(int(elapsed.total_seconds()), 3600)
            minutes, seconds = divmod(remainder, 60)
            uptime = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
        
        return {
            'cpu': f"{cpu_percent:.1f}%",
            'memory': f"{memory.percent:.1f}%",
            'commands': self.commands_executed,
            'sessions': len([t for t in self.targets.values() if t['status'] == 'online']),
            'uptime': uptime
        }

state = SystemState()

def hash_password(password):
    """ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±"""
    return hashlib.sha256(password.encode()).hexdigest()

def login_required(f):
    """Decorator Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„"""
    def decorated_function(*args, **kwargs):
        if not session.get('logged_in'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    decorated_function.__name__ = f.__name__
    return decorated_function

@app.route('/')
def login():
    """ØµÙØ­Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„"""
    if session.get('logged_in'):
        return redirect(url_for('dashboard'))
    return render_template('login.html')

@app.route('/login', methods=['POST'])
def do_login():
    """Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„"""
    try:
        data = request.get_json()
        password = data.get('password', '')
        
        # ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ù…Ø¯Ø®Ù„Ø©
        password_hash = hash_password(password)
        
        if password_hash == ADMIN_PASSWORD_HASH:
            session['logged_in'] = True
            session.permanent = True
            state.add_log('INFO', 'âœ… Admin logged in successfully')
            return jsonify({'success': True})
        else:
            state.add_log('WARNING', 'âŒ Failed login attempt')
            return jsonify({'success': False, 'error': 'Invalid password'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/logout')
def logout():
    """ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬"""
    session.clear()
    state.add_log('INFO', 'ğŸ‘‹ Admin logged out')
    return redirect(url_for('login'))

@app.route('/dashboard')
@login_required
def dashboard():
    """Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…"""
    return render_template('dashboard.html')

@app.route('/api/listener/start', methods=['POST'])
@login_required
def start_listener():
    """Ø¨Ø¯Ø¡ Ø®Ø§Ø¯Ù… Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ"""
    try:
        if state.is_running:
            return jsonify({'success': False, 'error': 'Listener already running'})
        
        data = request.get_json()
        host = data.get('host', '0.0.0.0')
        port = int(data.get('port', 4444))
        
        state.listener_host = host
        state.listener_port = port
        
        # Ø¨Ø¯Ø¡ netcat listener Ø­Ù‚ÙŠÙ‚ÙŠ
        state.listener_process = subprocess.Popen(
            ['nc', '-lvnp', str(port)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE,
            bufsize=0
        )
        
        state.is_running = True
        state.start_time = datetime.now()
        state.stop_monitor = False
        
        # Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
        state.connection_monitor_thread = threading.Thread(
            target=monitor_connections, 
            daemon=True
        )
        state.connection_monitor_thread.start()
        
        state.add_log('SUCCESS', f'ğŸš€ Listener started on {host}:{port}')
        
        return jsonify({
            'success': True,
            'message': f'Listener started on {host}:{port}'
        })
        
    except Exception as e:
        state.add_log('ERROR', f'âŒ Failed to start listener: {str(e)}')
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/listener/stop', methods=['POST'])
@login_required
def stop_listener():
    """Ø¥ÙŠÙ‚Ø§Ù Ø®Ø§Ø¯Ù… Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹"""
    try:
        if not state.is_running:
            return jsonify({'success': False, 'error': 'Listener not running'})
        
        # Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
        state.stop_monitor = True
        
        # Ø¥Ù†Ù‡Ø§Ø¡ Ø¹Ù…Ù„ÙŠØ© netcat
        if state.listener_process:
            state.listener_process.terminate()
            time.sleep(0.5)
            if state.listener_process.poll() is None:
                state.listener_process.kill()
            state.listener_process = None
        
        state.is_running = False
        state.add_log('INFO', 'â¹ï¸ Listener stopped')
        
        return jsonify({'success': True, 'message': 'Listener stopped'})
        
    except Exception as e:
        state.add_log('ERROR', f'âŒ Failed to stop listener: {str(e)}')
        return jsonify({'success': False, 'error': str(e)})

def monitor_connections():
    """Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„ÙˆØ§Ø±Ø¯Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©"""
    state.add_log('INFO', 'ğŸ‘ï¸ Connection monitor started')
    
    while not state.stop_monitor and state.is_running:
        try:
            # ÙØ­Øµ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… netstat
            if state.listener_port:
                scan_active_connections(state.listener_port)
            
            time.sleep(5)  # ÙØ­Øµ ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ
            
        except Exception as e:
            state.add_log('ERROR', f'Monitor error: {str(e)}')
            time.sleep(10)
    
    state.add_log('INFO', 'ğŸ‘ï¸ Connection monitor stopped')

def scan_active_connections(port):
    """ÙØ­Øµ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ÙØ°"""
    try:
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… netstat Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
        result = subprocess.run(
            ['netstat', '-tn'],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if result.returncode == 0:
            lines = result.stdout.split('\n')
            for line in lines:
                if f':{port}' in line and 'ESTABLISHED' in line:
                    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ IP Ø§Ù„Ø¨Ø¹ÙŠØ¯
                    parts = line.split()
                    if len(parts) >= 5:
                        remote_addr = parts[4]
                        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ IP ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† Ø§Ù„Ù…Ù†ÙØ°)
                        ip_match = re.match(r'(\d+\.\d+\.\d+\.\d+):', remote_addr)
                        if ip_match:
                            ip = ip_match.group(1)
                            # ØªØ¬Ø§Ù‡Ù„ localhost
                            if not ip.startswith('127.'):
                                state.add_target(ip)
        
    except Exception as e:
        pass  # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©

@app.route('/api/connections/scan', methods=['POST'])
@login_required
def scan_connections():
    """ÙØ­Øµ ÙŠØ¯ÙˆÙŠ Ù„Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©"""
    try:
        if not state.is_running or not state.listener_port:
            return jsonify({
                'success': False, 
                'error': 'Listener not running'
            })
        
        state.add_log('INFO', 'ğŸ” Manual scan initiated')
        
        # ÙØ­Øµ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
        scan_active_connections(state.listener_port)
        
        return jsonify({
            'success': True,
            'targets_found': len(state.targets),
            'message': f'Scan complete. Found {len(state.targets)} target(s)'
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/command/execute', methods=['POST'])
@login_required
def execute_command():
    """ØªÙ†ÙÙŠØ° Ø£Ù…Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ø¯Ù…"""
    try:
        data = request.get_json()
        command = data.get('command', '').strip()
        
        if not command:
            return jsonify({'success': False, 'error': 'No command provided'})
        
        state.add_log('INFO', f'ğŸ’» Executing: {command}')
        
        # ØªÙ†ÙÙŠØ° Ø§Ù„Ø£Ù…Ø±
        result = subprocess.run(
            command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30
        )
        
        output = result.stdout if result.stdout else result.stderr
        if not output:
            output = "Command executed (no output)"
        
        state.commands_executed += 1
        
        return jsonify({
            'success': True,
            'output': output,
            'returncode': result.returncode
        })
        
    except subprocess.TimeoutExpired:
        return jsonify({'success': False, 'error': 'Command timeout'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/stats', methods=['GET'])
@login_required
def get_stats():
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…"""
    return jsonify(state.get_stats())

@app.route('/api/status', methods=['GET'])
@login_required
def get_status():
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø§Ø¯Ù…"""
    return jsonify({
        'is_running': state.is_running,
        'port': state.listener_port,
        'host': state.listener_host,
        'targets_count': len(state.targets)
    })

@app.route('/api/targets', methods=['GET'])
@login_required
def get_targets():
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©"""
    return jsonify({
        'targets': list(state.targets.values())
    })

@app.route('/api/logs', methods=['GET'])
@login_required
def get_logs():
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¬Ù„Ø§Øª"""
    return jsonify({'logs': state.logs})

@socketio.on('connect')
def handle_connect():
    """Ø¹Ù†Ø¯ Ø§ØªØµØ§Ù„ Ø¹Ù…ÙŠÙ„ WebSocket"""
    if not session.get('logged_in'):
        return False
    state.add_log('INFO', 'ğŸ”Œ Client connected')

@socketio.on('disconnect')
def handle_disconnect():
    """Ø¹Ù†Ø¯ Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„ Ø¹Ù…ÙŠÙ„"""
    if session.get('logged_in'):
        state.add_log('INFO', 'ğŸ”Œ Client disconnected')

def periodic_stats_update():
    """Ø¥Ø±Ø³Ø§Ù„ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¨Ø´ÙƒÙ„ Ø¯ÙˆØ±ÙŠ"""
    while True:
        time.sleep(2)
        if state.is_running:
            try:
                socketio.emit('stats_update', state.get_stats())
            except:
                pass

if __name__ == '__main__':
    # Ø¨Ø¯Ø¡ thread Ù„Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø¯ÙˆØ±ÙŠØ©
    stats_thread = threading.Thread(target=periodic_stats_update, daemon=True)
    stats_thread.start()
    
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘   ğŸ”¥ PenTest C2 Dashboard - REAL VERSION                 â•‘")
    print("â•‘   Dashboard Ø­Ù‚ÙŠÙ‚ÙŠ 100% - Ù„Ø§ ØªÙˆØ¬Ø¯ targets ÙˆÙ‡Ù…ÙŠØ©          â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print()
    print("ğŸ“ Dashboard URL: http://localhost:5000")
    print("ğŸ” Password: hamza_sku_2026")
    print()
    print("âš ï¸  LEGAL WARNING:")
    print("    This tool is for AUTHORIZED testing only!")
    print("    Unauthorized access is ILLEGAL!")
    print()
    
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø®Ø§Ø¯Ù…
    socketio.run(app, host='0.0.0.0', port=5000, debug=False, allow_unsafe_werkzeug=True)
